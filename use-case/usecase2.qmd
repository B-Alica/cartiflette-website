---
title: "Faire une carte avec les DROM rapproch√©s gr√¢ce √† cartiflette"
output: true
number-sections: true
code-annotations: hover
author: "Lino Galiana"
---

::: {.important}
Cette page est un _work in progress_! Des exemples dans d'autres langages que `Python` {{< fa brands python >}} viendront ult√©rieurement. 

Cette page fait partie d'une s√©rie de tutoriels illustrant les fonctionnalit√©s de `cartiflette`. Pour retrouver la liste de ceux-ci, c'est [ici](/use-case/index.qmd)
:::

Ce tutoriel vise √† illustrer un cas d'usage classique de `cartiflette` : __r√©cup√©rer de mani√®re flexible un fonds de carte dont les [DROM sont rapproch√©s]{.yellow} et o√π on voit [un zoom sur l'Ile de France]{.yellow}__.  

Ce besoin classique est illustr√© en r√©pliquant la carte faite par [Jules Grandin pour son podcast "La Minute Cartographique"](https://www.youtube.com/watch?v=mK7Hr2x895k)
L'objectif final de ce tutoriel est de faire cette carte:

```{ojs}
//| echo: false
html`<div>${carte_interactive_js}</div>`
```


```{ojs}
//| echo: false
viewof beteview = Inputs.bind(
    Inputs.radio(
        new Map([["Vaches üêÆ", "Bovins"], ["Cochons üê∑", "Porcins"], ["Moutons üêë", "Ovins"]]), {value: "Bovins"}
    ),
    viewof bete
)
```

```{ojs}
//| echo: false
carte_interactive_js = html`
<div class="bouton-cheptel">${viewof beteview}</div>
<div class="titre-carte-cheptel"><h3>${title_chosen}</h3></div>
<div class="carte-cheptel">${produceMap(cheptel, bete)}<div>
`
```

<details>
<summary>
Voir l'√©pisode en question de  "La Minute Cartographique"
</summary>

{{< video https://www.youtube.com/embed/mK7Hr2x895k?si=6nNRsJziuUjGsP5B >}}


</details>

# Pr√©liminaire: r√©cup√©ration des cheptels fran√ßais

La vid√©o de Jules Grandin √©voque une ouverture et pr√©paration des donn√©es dans Excel üò±. N√©anmois, en quelques lignes de code, on peut render ces donn√©es propres √† l'analyse statistique et cartographique avec `Python` {{< fa brands python >}} üòå


```{python}
#| code-fold: true
#| code-summary: "Pr√©paration des donn√©es avec Pandas"

import pandas as pd

def import_cheptel():
    url_cheptel = "https://www.insee.fr/fr/statistiques/fichier/2012795/TCRD_073.xlsx"

    cheptel2022 = pd.read_excel(url_cheptel, header=3, na_values="nd") #<1>
    type_cheptel = cheptel2022.columns[~cheptel2022.columns.str.startswith("Unnamed")] #<2>
    cheptel2022.loc[:, type_cheptel] = cheptel2022.loc[:, type_cheptel].mul(1000) #<3>
    cheptel2022 = cheptel2022.rename(
        {
            "Unnamed: 0": "code",
            "Unnamed: 1": "departement",
            "Volailles gallus": "Volailles",
        },
        axis="columns",
    ) #<4>
    type_cheptel = type_cheptel.str.replace(" gallus", "")
    return cheptel2022, type_cheptel #<5>

cheptel = import_cheptel()

cheptel[0].head(4)
```
1. Les premi√®res lignes sont de la documentation, les donn√©es ne commencent r√©ellement que ligne 4
2. Extraction du type de b√™tes, cela sera plus utile ult√©rieurement 
3. Les donn√©es sont en milliers de t√™te, on ajuste pour pouvoir comparer √† la population
4. La ligne correspondant aux noms de variable n'est pas compl√®te dans le Excel. Il faut donc retravailler les noms de colonnes.
5. On renvoie la donn√©e et la liste des b√™tes

En ce qui concerne la population, qui nous servira au d√©nominateur de notre indicateur, nous allons utiliser la variable fournie dans les donn√©es r√©cup√©r√©es par le biais de `cartiflette`[^pop-legale].

[^pop-legale]: Dans l'id√©al, nous utiliserions les [populations l√©gales](https://www.insee.fr/fr/statistiques/7728787?sommaire=7728826) mesur√©es par l'Insee. Les fonds de carte de l'IGN proposent n√©anmoins d√©j√† une variable `POPULATION` qui est celle qui sera utilis√©e ici. Des travaux ult√©rieurs sur `cartiflette` viseront √† remplacer cette variable par les populations l√©gales pour assurer que les m√©tadonn√©es utilis√©es par les fonds de carte correspondent, au m√™me titre que les d√©coupages g√©om√©triques, aux donn√©es officielles.  


# R√©cup√©rer les contours modifi√©s via `cartiflette`

## La r√©cup√©ration des donn√©es utilisant `cartiflette`

```{python}
#| echo: false
import time
start_time_cartiflette = time.time()
```

Notre objectif est de faire une carte aux caract√©ristiques suivantes:

* Les DROM sont rapproch√©s de la France hexagonale en √©tant plac√©s sous celle-ci ;
* Un cartogramme zoom√© de la petite couronne parisienne (d√©partements de la Seine, Hauts-de-Seine, Seine-Saint-Denis et Val de Marne) est disponible en haut √† gauche de celle-ci.

Construire soi-m√™me ce fonds de carte est fastidieux, comme l'illustre la partie [Comment faire sans cartiflette](#sans-cartiflette). Avec `cartiflette`, ce fonds de carte est pr√©construit √† partir des d√©coupages officiels de l'IGN. Il suffit de remplace le niveau `FRANCE_ENTIERE` en `FRANCE_ENTIERE_DROM_RAPPROCHES` dans l'appel √† `carti_download`.  

::: {#lst-cartiflette-example lst-cap="Example d'utilisation de cartiflette"}

```{python}
#| code-line-numbers: true
from cartiflette import carti_download

departements = carti_download(
    values="France",
    crs=4326,
    borders="DEPARTEMENT",
    vectorfile_format="geojson",
    filter_by="FRANCE_ENTIERE_DROM_RAPPROCHES",
    source="EXPRESS-COG-CARTO-TERRITOIRE",
    year=2022,
)
```

:::

```{python}
#| echo: false
end_time_cartiflette = time.time()
```

`departements` est un `GeoDataFrame` classique proposant les m√©tadonn√©es usuelles de `cartiflette` avec des g√©ographies modifi√©es pour rapprocher la France des DROM[^warning-crs].  

[^warning-crs]: Ce fonds de carte est en g√©om√©trie WGS84 (CRS: 4326). Ce n'est n√©anmoins qu'une apparence car les g√©om√©tries n√©cessaires pour repr√©senter les DROM et l'Ile de France sur cette carte ne correspondent √† aucune r√©alit√© terrestre. Il ne faut donc consid√©rer ce fonds de carte que pour la cartographie finale, pas la manipulation de donn√©es g√©ographique (par exemple pour un calcul de distance terrestre). Pour celles-ci, le fonds de carte normal √† utiliser est `FRANCE_ENTIERE`. 

```{python}
departements.boundary.plot(edgecolor = "black", linewidth=0.2)
```



## Association du fonds de carte `cartiflette` au jeu de donn√©es initial

La suite du travail n'est pas intrins√®quement li√© √† `cartiflette` mais correspond √† de la manipulation de donn√©es spatiales n√©cessaires √† la finalisation de la carte. 

Comme nous avons besoin de localiser les d√©comptes d√©partements de b√©tail, nous faisons une jointure spatiale entre notre fonds de carte et nos cheptels

```{python}
cheptel_geospatial = departements.merge(
    cheptel[0], left_on="INSEE_DEP", right_on = "code"
)
```

A partir de l√†, on finalise notre travail sur le 
jeu de donn√©es pour calculer le ratio entre le nombre
de t√™tes et la population:

```{python}
#| code-fold: true
#| code-summary: "D√©rouler pour voir la finalisation du travail de donn√©es"

def ratio_cheptel(type_cheptel, data_departement):
    """
    Fonction permettant de rapporter, pour un type de b√™te donn√©,
    le nombre de t√™tes par habitant d'un d√©partement 
    """
    data_departement = data_departement.copy()
    data_departement["ratio_" + type_cheptel] = (
        data_departement.loc[:, type_cheptel]
        .div(data_departement["POPULATION"], axis=0)
    )
    data_departement["more_" + type_cheptel] = (
        data_departement["ratio_" + type_cheptel] > 1
    )
    return data_departement.loc[:, "more_" + type_cheptel]

eval_ratio = pd.concat(
    [ratio_cheptel(bete, cheptel_geospatial) for bete in cheptel[1]],
    axis = 1
) #<1>

cheptel_geospatial = pd.concat(
    [cheptel_geospatial, eval_ratio],
    axis = 1
) #<2>
```
1. Un _DataFrame_ temporaire permettant de d√©finir, par le biais d'une boucle, nos indicateurs de population.
2. On associe ces nouvelles colonnes √† nos donn√©es initiales

Le jeu de donn√©es pr√™t √† l'emploi prend la forme suivante:

```{python}
cheptel_geospatial.head(2)
```

## Production de la carte interactive

On peut maintenant se concentrer sur la carte. Pour la rendre plus informative, il est utile de contextualiser les d√©partements en permettant aux spectateurs de la carte de conna√Ætre le nom des d√©partements ayant un cheptel plus important que sa population. 

Cela peut √™tre fait comme sur la carte d'origine de Jules Grandin en inscrivant les noms des d√©partements concern√©s sur celle-ci. Cela n√©cessite tout de m√™me un travail manuel important pour qui n'utilise pas une interface comme QGIS. 

Il est plus simple, pour les utilisateurs de logiciels comme `Python`, `R` ou `Javascript` de produire une carte interactive qui permet d'afficher des valeurs lorsqu'on passe la souris dessus. Il existe plusieurs √©cosyst√®mes pour faire cela, plus ou moins directement reli√©s √† `Javascript`, le langage consacr√© pour ce type d'applications r√©actives. 

Les exemples ci-dessous proposent un code en `Python` pour faire une carte interactive par le biais de la librairie `Folium`. Cette mani√®re de proc√©der √©tant un peu fastidieuse, car `Folium` n'est pas initialement con√ßu pour ce type de cartes, il est recommand√© de privil√©gier la solution `Observable` qui est un _framework_ `Javascript` ressemblant beaucoup √† `Python` mais plus adapt√© que ce dernier pour la _dataviz_.


En premier lieu, on d√©finit une fonction g√©n√©rique qui permet de construire, pour un type de cheptel donn√©, la carte qui sera cr√©√©e:


```{python}
#| code-fold: true
#| code-summary: "D√©finition d'une fonction g√©n√©rique pour cr√©er la carte"
import folium
import branca

palettes = {
    "Bovins": {True: "#f9b439", False: "#d8d4d3"},
    "Porcins": {True: "#ec6569", False: "#d8d4d3"},
    "Ovins": {True: "#5eb04e", False: "#d8d4d3"},
    "Caprins": {True: "#5eb04e", False: "#d8d4d3"}
}

# Function to apply color based on the 'more_XXXXX' values
def style_function(feature, bete):
    more_bovins = feature['properties'][f'more_{bete}']
    return {
        'fillColor': palettes[bete][more_bovins],
        'color': 'black',
        'weight': 1,
        'fillOpacity': 0.7,
    }


def map_repartition(cheptel_geospatial, bete):
    white_tile = branca.utilities.image_to_url([[1, 1], [1, 1]]) #<1>

    # Initialize a folium map
    m = folium.Map(
        location=[
            cheptel_geospatial.geometry.centroid.y.mean(), cheptel_geospatial.geometry.centroid.x.mean()
        ],
        zoom_start=5,
        tiles=white_tile, attr="white tile"
    )


    # Add GeoJson layer to the map
    folium.GeoJson(
        cheptel_geospatial,
        style_function=lambda x: style_function(x, bete),
        tooltip=folium.GeoJsonTooltip(
            fields=['LIBELLE_DEPARTEMENT', 'POPULATION', bete],
            aliases=['Department:', 'Population:', f'{bete}:'],
            localize=True
        )
    ).add_to(m)

    return m
```
1. `Folium` est une librairie qui est pens√©e, avant tout, pour proposer un fonds de carte type `OpenStreetMap` en arri√®re-plan. Celui-ci ne nous int√©resse pas ici car nous avons cr√©√© des √©l√©ments sans contrepartie sur la Terre (les DROM sous la France, le zoom de l'Ile de France au nord ouest de la Normandie). Nous cr√©ons donc un fond blanc qui est utilis√© de mani√®re d√©tourn√©e par Folium. 


Pour cr√©er celles-ci, il suffit d√®s lors d'appliquer la fonction sur le type d'√©levage d√©sir√©:


```{python}
#| eval: false
#| code-fold: true
#| code-summary: "Visualiser par le biais de Folium"
map_repartition(cheptel_geospatial, "Bovins")
map_repartition(cheptel_geospatial, "Porcins")
map_repartition(cheptel_geospatial, "Ovins")
```

N√©anmoins, ce n'est pas la m√©thode adopt√©e pour cr√©er les cartes ci-dessous:


```{ojs}
//| echo: false
html`<div>${carte_interactive_js2}</div>`
```

Pour cela, il vaut mieux utiliser `Javascript` par le biais d'`Observable` dont le code est disponible dans la boite d√©roulable ci-dessous:

::: {.callout-tip collapse="true"}
## Comment faire avec `Javascript` ?

Ce tutoriel utilise le _framework_ `Observable` par le biais de `Quarto`, l'outil de construction de site web d√©velopp√© par `Posit`. Le code source de cette page est disponible [ici](https://github.com/InseeFrLab/cartiflette-website/blob/master/use-case/usecase2.qmd)[^asynchrone].

[^asynchrone]: `Javascript` est un langage asynchrone donc l'ex√©cution du code ne d√©pend pas de l'ordre de d√©finition des objets dans le code, contrairement √† `Python`. Il est donc normal de voir dans les codes ci-dessous une utilisation d'une variable, par exemple `bete`, qui n'est pas d√©finie en amont. Celle-ci peut √™tre d√©finie plus loin dans le code, c'est `Javascript` qui va r√©ordonner de mani√®re logique l'ex√©cution du code. 

Pour se simplifier la t√¢che, on va cr√©er une fonction graphique qui prend en _input_ un `Array` et un type d'√©levage (par exemple _"Bovins"_) et renvoie une carte:

```{ojs}
//| echo: false
import {addTooltips} from "@mkfreeman/plot-tooltip"

function produceMap(cheptel, bete){
    const carte = addTooltips(
        Plot.plot({ 
            marginLeft: 0,
            marginRight: 0,
            width: 400,
            height: 400,  
            color: {
            legend: true,
            value: [
                labels.filter(d => d.type == bete)[0].true,
                labels.filter(d => d.type == bete)[0].false        
            ],
            range: [
                palettes.filter(d => d.name == bete)[0].trueColor,
                palettes.filter(d => d.name == bete)[0].falseColor
            ],
            label: "Alors ?"
            },
            y: {axis: null},
            x: {axis: null},
            marks: [
            Plot.geo(cheptel, {
                fill: (d) => labels.filter(d => d.type == bete)[0][d.properties[bete] > d.properties.POPULATION],
                sort: {
                color: "fill",
                reverse: true
                },
                title: (d) => `${d.properties.LIBELLE_DEPARTEMENT} (${d.properties.INSEE_DEP}) \nCheptel: ${d.properties[bete]} \nPopulation: ${d.properties.POPULATION}  \n Ratio: ${(d.properties[bete]/d.properties.POPULATION).toLocaleString(undefined, {maximumSignificantDigits: 2})}`,
            })
            ]
        })
    )
    return carte
}
```

Celle-ci utilise un certain nombre d'ingr√©dients. En premier lieu, des _arrays_ permettant de changer les valeurs affich√©es en fonction de la valeur du _widget_ s√©lectionn√© :

```{ojs}
labels = [
    {type: "Bovins", true: "Plus de vaches üêÆ", false: "Plus d'habitants"},
    {type: "Porcins", true: "Plus de cochons üê∑", false: "Plus d'habitants"},
    {type: "Ovins", true: "Plus de moutons üêë", false: "Plus d'habitants"},
    {type: "Caprins", true: "Plus de ch√®vres üêê", false: "Plus d'habitants"}
]
title = [
    {type: "Bovins", title: "Plus de vaches üêÆ ou d'habitants ?"},
    {type: "Porcins", title: "Plus de cochons üê∑ ou d'habitants ?"},
    {type: "Ovins", title: "Plus de moutons üêë ou d'habitants ?"},
    {type: "Caprins", title: "Plus de ch√®vres üêê ou d'habitants ?"}
]
palettes = [
    {
        name: "Bovins",
        trueColor: "#f9b439",
        falseColor: "#d8d4d3"
    },
    {
        name: "Porcins",
        trueColor: "#ec6569",
        falseColor: "#d8d4d3"
    },
    {
        name: "Ovins",
        trueColor: "#5eb04e",
        falseColor: "#d8d4d3"
    },
    {
        name: "Caprins",
        trueColor: "#00b5ed",
        falseColor: "#d8d4d3"
    }
]

title_chosen = title.filter(d => d.type == bete)[0].title
```


```{ojs}
//| echo: false
carte_interactive_js2 = html`
<div class="bouton-cheptel">${viewof bete}</div>
<div class="titre-carte-cheptel"><h3>${title_chosen}</h3></div>
<div class="carte-cheptel">${produceMap(cheptel, bete)}<div>
`
```

Ce _widget_ est un [radio button](https://developer.mozilla.org/fr/docs/Web/HTML/Element/input/radio) qui peut √™tre cr√©√© par le code suivant, permettant √† la fois d'exposer celui-ci sur l'interface et de stocker sa valeur active dans la variable `bete`

```{ojs}
viewof bete = Inputs.radio(
    new Map([["Vaches üêÆ", "Bovins"], ["Cochons üê∑", "Porcins"], ["Moutons üêë", "Ovins"]]), {value: "Bovins"}
)
```

Il ne manque qu'√† importer les donn√©es n√©cessaires √† la carte dans `Javascript`. La fonction [`ojs_define`](https://quarto.org/docs/interactive/ojs/data-sources.html)  permettant la transmission d'un objet `Python` √† `R` ne fonctionnant pas pour un `GeoPandas`, le plus simple est de cr√©er un GeoJSON en `Python` : 

```{python}
cheptel_geospatial.to_file(
    "cheptel.json", driver="GeoJSON"
)
```

Il suffit ensuite d'importer celui-ci avec la fonction [`FileAttachment`](https://quarto.org/docs/interactive/ojs/data-sources.html) d'`Observable`

```{ojs}
cheptel = FileAttachment("cheptel.json").json()
```

:::

# Comment faire sans `cartiflette` ? {.sans-cartiflette}

* 1Ô∏è‚É£ T√©l√©charger les donn√©es et les enregistrer sur le disque, en local.
* 2Ô∏è‚É£ D√©zipper la version t√©l√©charg√©e (le format est une archive 7z) et enregistrer l'arborescence obtenue sur le disque.
* 3Ô∏è‚É£ Importer le bon _shapefile_ dans `Python` et d√©couper celui-ci en diff√©rents espaces qui seront reprojet√©s
* 4Ô∏è‚É£ Pour chaque DROM et d√©partement de l'√éle de France, modifier la g√©om√©trie en jouant sur des translations et rotations
* 5Ô∏è‚É£ Consolider le fond de carte √† partir des diff√©rents √©l√©ments obtenus

La premi√®re √©tape consiste donc √† t√©l√©charger le fichier depuis le site de mise √† disposition de l'IGN. L'archive √©tant assez volumineuse, le code propos√© propose une barre de progr√®s pour s'assurer que le t√©l√©chargement progresse.

Le code √©tant assez long, il n'est pas apparent par d√©faut mais il suffit de cliquer ci-dessous:

::: {#lst-example-download-adminexpress lst-cap="1Ô∏è‚É£ Code pour t√©l√©charger les donn√©es"}

{{< include "/use-case/scripts/_01_telecharger_admin.qmd" >}}

:::


La deuxi√®me √©tape consiste √† d√©zipper la version t√©l√©charg√©e en local


::: {#lst-example-unzip-adminexpress lst-cap="2Ô∏è‚É£ D√©zipper la version t√©l√©charg√©e"}

{{< include "/use-case/scripts/_02_unzip_admin.qmd" >}}

:::


```{python}
import geopandas as gpd

path_extraction = "./extracted_files/ADMIN-EXPRESS-COG-CARTO_3-1__SHP_WGS84G_FRA_2022-04-15/ADMIN-EXPRESS-COG-CARTO/1_DONNEES_LIVRAISON_2022-04-15/ADECOGC_3-1_SHP_WGS84G_FRA/"

# Limites communales
france = gpd.read_file(f"{path_extraction}/COMMUNE.shp")
hexagone = france.loc[
    ~france["INSEE_DEP"].isin(["971", "972", "973", "974", "976"])
]
guadeloupe = france.loc[france["INSEE_DEP"] == "971"]
martinique = france.loc[france["INSEE_DEP"] == "972"]
guyane = france.loc[france["INSEE_DEP"] == "973"]
reunion = france.loc[france["INSEE_DEP"] == "974"]
mayotte = france.loc[france["INSEE_DEP"] == "976"]
```


```{python}
#| eval: false
#| echo: false

from shapely.affinity import translate, scale
martinique_mod = martinique.copy()
x_offset = -6.0  # Par exemple, translation vers l'ouest
y_offset = 10.0  # Par exemple, translation vers le nord

# Translation de la Martinique (6480000, 3505000 en unit√©s de la projection)
x_shift = 6480000
y_shift = 3505000
martinique['geometry'] = martinique['geometry'].apply(lambda geom: translate(geom, xoff=x_shift, yoff=y_shift))

# Mise √† l'√©chelle de la Martinique (1.5x)
scale_factor = 1.5
martinique['geometry'] = martinique['geometry'].apply(lambda geom: scale(geom, xfact=scale_factor, yfact=scale_factor, origin=(0, 0)))
martinique.to_crs(4326)

martinique_mod = martinique.copy().to_crs(3857)
martinique_mod["trans_geometry"] = (
    martinique_mod
    .scale(
        xfact=1.5, yfact=1.5, origin=(0, 0)
    )
    .translate(6480000, 3505000)
)
martinique_mod = (
    martinique_mod
    .set_geometry("trans_geometry", crs=3857)
    .drop("geometry", axis="columns")
    .to_crs(4326)
)
pd.concat([hexagone, martinique_mod]).plot()

reunion = dev.get_vectorfile_ign(level="COMMUNE", field="reunion")
reunion_mod = reunion
reunion_mod.crs = 2154
reunion_mod["trans_geometry"] = (
    reunion_mod.scale(xfact=1.75, yfact=1.75, origin=(0, 0))
    .to_crs(2154)
    .translate(-422169, -7132230)
)
reunion_mod = reunion_mod.set_geometry("trans_geometry", crs=2154).drop(
    "geometry", axis="columns"
)


guadeloupe = dev.get_vectorfile_ign(level="COMMUNE", field="guadeloupe")
guadeloupe = guadeloupe
guadeloupe.crs = 2154
guadeloupe["trans_geometry"] = (
    guadeloupe.scale(xfact=1.32, yfact=1.32, origin=(0, 0))
    .to_crs(2154)
    .translate(-699983, 4269050)
    .to_crs(4326)
)
guadeloupe = guadeloupe.set_geometry("trans_geometry", crs=2154).drop(
    "geometry", axis="columns"
)

guyane = dev.get_vectorfile_ign(level="COMMUNE", field="guyane")
guyane = guyane
guyane.crs = 2154
guyane["trans_geometry"] = (
    guyane.scale(xfact=0.25, yfact=0.25, origin=(0, 0))
    .to_crs(2154)
    .translate(118687, 6286270)
    .to_crs(4326)
)
guyane = guyane.set_geometry("trans_geometry", crs=2154).drop(
    "geometry", axis="columns"
)

zoom = france.loc[france["INSEE_DEP"].isin(["75", "92", "93", "94"])]
zoom["trans_geometry"] = (
    zoom.scale(xfact=2.78, yfact=2.78, origin=(0, 0))
    .to_crs(2154)
    .translate(-1634506, -12046235)
    .to_crs(4326)
)
zoom = zoom.set_geometry("trans_geometry", crs=2154).drop("geometry", axis="columns")
```
