---
title: "Faire une carte avec les DROM rapproch√©s gr√¢ce √† cartiflette"
output: true
number-sections: true
code-annotations: hover
---

::: {.important}
Cette page est un _work in progress_! Des exemples dans d'autres langages que `Python` {{< fa brands python >}} viendront ult√©rieurement. 

Cette page fait partie d'une s√©rie de tutoriels illustrant les fonctionnalit√©s de `cartiflette`. Pour retrouver la liste de ceux-ci, c'est [ici](/use-case/index.qmd)
:::

Ce tutoriel vise √† illustrer un cas d'usage classique de `cartiflette` : __r√©cup√©rer de mani√®re flexible un fonds de carte dont les [DROM sont rapproch√©s]{.yellow} et o√π [un deuxi√®me]{.yellow}__.  

Ce besoin classique est illustr√© en r√©pliquant la carte faite par [Jules Grandin "Plus de vaches ou d'habitants"](https://x.com/JulesGrandin/status/1531631375505399809?mx=2)


# Pr√©liminaire: r√©cup√©ration des cheptels fran√ßais

La vid√©o de Jules Grandin √©voque une ouverture et pr√©paration des donn√©es dans Excel üò±. N√©anmois, en quelques lignes de code, on peut render ces donn√©es propres √† l'analyse statistique et cartographique avec `Python` üòå


```{python}
#| code-fold: true
#| code-summary: "Pr√©paration des donn√©es avec Pandas"

import pandas as pd

def import_cheptel():
    url_cheptel = "https://www.insee.fr/fr/statistiques/fichier/2012795/TCRD_073.xlsx"

    cheptel2022 = pd.read_excel(url_cheptel, header=3, na_values="nd") #<1>
    type_cheptel = cheptel2022.columns[~cheptel2022.columns.str.startswith("Unnamed")] #<2>
    cheptel2022.loc[:, type_cheptel] = cheptel2022.loc[:, type_cheptel].mul(1000) #<3>
    cheptel2022 = cheptel2022.rename(
        {
            "Unnamed: 0": "code",
            "Unnamed: 1": "departement",
            "Volailles gallus": "Volailles",
        },
        axis="columns",
    )
    type_cheptel = type_cheptel.str.replace(" gallus", "")
    return cheptel2022, type_cheptel #<4>

cheptel = import_cheptel()
```
1. Les premi√®res lignes sont de la documentation, les donn√©es ne commencent r√©ellement que ligne 4
2. Extraction du type de b√™tes, cela sera plus utile ult√©rieurement 
3. Les donn√©es sont en milliers de t√™te, on ajuste pour pouvoir comparer √† la population
4. On renvoie la donn√©e et la liste des b√™tes


# R√©cup√©rer les contours n√©cessaires via `cartiflette`


```{python}
from cartiflette import carti_download
dep = carti_download(
    values=["France"],
    crs=4326,
    borders="DEPARTEMENT",
    vectorfile_format="geojson",
    filter_by="FRANCE_ENTIERE_DROM_RAPPROCHES",
    source="EXPRESS-COG-CARTO-TERRITOIRE",
    year=2022,
)
```


```{python}
cheptel_geospatial = dep.merge(
    cheptel[0], left_on="INSEE_DEP", right_on = "code"
)
```

```{python}
def ratio_cheptel(type_cheptel, data_departement):
    data_departement = data_departement.copy()
    data_departement["ratio_" + type_cheptel] = data_departement.loc[
        :, type_cheptel
    ].div(data_departement["POPULATION"], axis=0)
    data_departement["more_" + type_cheptel] = (
        data_departement["ratio_" + type_cheptel] > 1
    )
    return data_departement.loc[:, "more_" + type_cheptel]
```


```{python}
eval_ratio = pd.concat(
    [ratio_cheptel(bete, cheptel_geospatial) for bete in cheptel[1]],
    axis = 1
)
cheptel_geospatial = pd.concat(
    [cheptel_geospatial, eval_ratio],
    axis = 1
)
```

title = {
    "Bovins": "Plus de vaches üêÆ ou d'habitants ?",
    "Porcins": "Plus de cochons üê∑ ou d'habitants ?",
    "Ovins": "Plus de ch√®vres üêê ou d'habitants ?"
}


```{python}
import folium
import branca

palettes = {
    "Bovins": {True: "#f9b439", False: "#d8d4d3"},
    "Porcins": {True: "#ec6569", False: "#d8d4d3"},
    "Ovins": {True: "#5eb04e", False: "#d8d4d3"}
}

# Function to apply color based on the 'more_Bovins' value
def style_function(feature, bete):
    more_bovins = feature['properties'][f'more_{bete}']
    return {
        'fillColor': palettes[bete][more_bovins],
        'color': 'black',
        'weight': 1,
        'fillOpacity': 0.7,
    }


def map_repartition(cheptel_geospatial, bete):
    # Create a white image of 4 pixels, and embed it in a url.
    white_tile = branca.utilities.image_to_url([[1, 1], [1, 1]])

    # Initialize a folium map
    m = folium.Map(location=[cheptel_geospatial.geometry.centroid.y.mean(), 
                            cheptel_geospatial.geometry.centroid.x.mean()], 
                zoom_start=5,
                tiles=white_tile, attr="white tile")


    # Add GeoJson layer to the map
    folium.GeoJson(
        cheptel_geospatial,
        style_function=lambda x: style_function(x, bete),
        tooltip=folium.GeoJsonTooltip(
            fields=['LIBELLE_DEPARTEMENT', 'POPULATION', bete],
            aliases=['Department:', 'Population:', f'{bete}:'],
            localize=True
        )
    ).add_to(m)

    return m
```



```{python}
#| eval: false
map_repartition(cheptel_geospatial, "Bovins")
```


```{python}
#| eval: false
map_repartition(cheptel_geospatial, "Porcins")
```

```{python}
#| eval: false
map_repartition(cheptel_geospatial, "Ovins")
```